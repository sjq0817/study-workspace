## 什么是函数
+ 函数就是语句的封装，可以让这些代码方便地被复用
+ 函数具有“一次定义，多次调用”的优点
+ 使用函数，可以简化代码，让代码具有可读性
### 函数的定义
+ 和变量类似，函数必须先定义然后才能使用
+ 使用function关键字定义函数，function是“功能”的意思
```
function fun() {
    //函数体语句
}

//匿名函数
var fun = function (){
    //函数语句体
}
```
### 函数的调用
+ 执行函数体中的所有语句，就称为“调用函数”
+ 调用函数非常简单，只需要在函数名字后面书写圆括号对即可
```
fun()//调用函数 
```
+ 语句执行顺序
+ 函数声明提升，和变量声明类似
+ 如果函数是用函数表达式的写法定义的，则没有提升特性
#### 函数的参数
+  参数是函数内的一些待定值，在调用函数时，必须传入这些参数的具体值
+ 函数的参数可多可少，函数可以没有参数，也可以有多个参数，多个参数之间需要用逗号隔开
#### arguments
+ 函数内arguments表示它接收到的实参列表，它是一个类数组对象
+ 类数组对象：所有属性均为从0开始的自然数序列，并且有length属性，和数组类似可以用方括号书写下标访问对象的某个属性值，但是不能调用数组的方法
#### 函数的返回值
+ 函数体内可以使用return关键字表示“函数的返回值”
```
function sum(a,b){
    return a+b;
}
var result = sum(3,5);
console.log(result);
```
+ 调用一个有返回值的函数，可以被当做一个普通值，从而可以出现任何可以书写值的地方
```
function sum(a,b){
    return a+b;
}
var result = sum(3,5)*sum(2,5);
console.log(result);
```
```
function sum(a,b){
    return a+b;
}
var result = sum(3,sum(3,5));
console.log(result);
```
+ 遇见return即退出函数
    + 调用函数时，一旦遇见return语句则会立即退出函数，将执行权交还调用者
    + 结合if语句的时候，往往不需要写else分支了

## 函数算法题
#### JavaScript内置sort()方法
+ 数组排序可以使用sort()方法,这个方法的参数又是一个函数
```
var arr = [33,22,55,11];
arr.sort(function(a,b){
    if(a > b){
        return 1;
    }else{
        return -1;
    }
});
```
```
var arr = [33,22,55,11];
arr.sort(function(a,b){
    return a-b;
});
console.log(arr);
```
+ 这个函数中的a,b分别表示数组中靠前和靠后的项,如果需要将它们交换位置,则返回任意正数;否则就返回负数
+ 函数是JS中的一等公民,它可以当做参数传入另一个函数
### 什么是递归
+ 函数的内部语句可以调用这个函数自身,从而发起对函数的一次迭代,在新的迭代中,又会执行调用函数自身的语句,从而又产生一次迭代.当函数执行到某次时,不再进行新的迭代,函数被一层一层返回,函数被递归
+ 递归是一种较为高级的编程技巧,它把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解
### 递归的要素
+ 边界条件:确定递归到何时终止,也称为递归出口
+ 递归模式:大问题是如何分解为小问题的,也称为递归体

### 递归常见算法题
+ 斐波那契数列
### 实现深克隆
+ 使用递归思想,整体思路和浅克隆类似,但稍微进行一些改动:如果遍历到项基本类型值,则直接推入结果数组,如果遍历到的项又是数组,则重复执行浅克隆的操作
### 全局变量和局部变量
+ JavaScript是函数级作用域编程语言:变量只在其定义时所在的function内部有意义
+ 全局变量:如果不将变量定义在任何函数的内部,此时这个变量就是全局变量,它在任何函数内都可以被访问和更改

#### 遮蔽效应
+ 如果函数中也定义了和全局同名的变量,则函数内的变量会将全局的变量"遮蔽"
+ 注意考虑变量声明提升
+ 形参也是局部变量

#### 作用域链
+ 函数的嵌套:一个函数内部也可以定义一个函数.和局部变量类似,定义在一个函数内部的函数是局部函数
+ 在函数嵌套中,变量会从内到外逐渐层寻找它的定义
+ 在初次给变量赋值时,如果没有加var,则将定义全局变量

## 闭包
+ 闭包(closure),闭包是函数本身和该函数声明时所处的环境状态的组合.
+ 函数能够记忆住其定义时所处的环境,即使函数不在其定义的环境中也能被调用,也能访问定义时所处环境的变量
+ 每次创建函数时都会创建闭包
+ 闭包特性往往需要将函数换一个地方执行才能被观察出来
+ 允许我们将数据与操作该数据的函数关联起来
+ 记忆性,模拟私有变量
##### 记忆性
+ 函数所处环境的状态会始终保持在内存中,不会在外层函数调用后被自动清除.
##### 模拟私有变量
+ 在JS中无私有属性概念只能用闭包模拟 
##### 使用闭包的注意点
+ 不能滥用闭包,否则会造成网页的性能问题,严重时可能导致内存泄漏.所谓内存泄漏是指程序中已动态分配的内存由于某种原因未释放或无法释放

### 立即执行函数IIFE
+ IIFE(immediately invoked function expression),立即调用函数表达式,是一种特殊的JavaScript函数写法,一旦被定义,就立即被调用
```
(function (){statements//任意语句})();

```
+ 函数不能直接加圆括号被调用
+ 函数必须转为"函数表达式"才能被调用

+ IIFE可以在一些场合（for）将全局变量变为局部变量